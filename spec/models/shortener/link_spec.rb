require 'rails_helper'

RSpec.describe Shortener::Link, type: :model do
  let(:long_url) { 'https://example.com/any/path?with=query&string=values' }

  context 'validations' do
    it { should validate_presence_of(:long_url) }

    it do
      link = Shortener::Link.create!(long_url: long_url, token: 'abC1234')

      expect(link).to validate_uniqueness_of(:token)
    end

    it 'does not allow create a custom token with a blocklisted domain' do
      [
        'http://127.0.0.1/any/path',
        'https://127.0.0.1:3000/any/path',
        'https://localhost/any/path',
        'http://localhost:5000/any/path',
        'https://4ny.us/any/path'
      ].each do |blocklisted_url|
        link = Shortener::Link.create(long_url: blocklisted_url)

        expect(link).to be_invalid
        expect(link.errors.messages[:long_url]).to eq ["#{URI.parse(blocklisted_url).hostname} is forbidden"]
      end
    end

    it 'performs basic validation of URI formats' do
      [
        'invalid',
        'invalid@test.com',
        '1.2.3.4.5.6',
        '12313',
      ].each do |invalid_uri|
        link = Shortener::Link.create(long_url: invalid_uri)

        expect(link).to be_invalid
        expect(link.errors.messages[:long_url]).to eq ['is invalid']
      end
    end

    it 'validate a max legnth of the long url for a broaden browser support' do
      max_long_url = "https://example.com/#{'x' * (Shortener::Link::MAX_LONG_URL_LENGTH - 20) }"
      invalid_long_url = max_long_url + 'x'

      link = Shortener::Link.create(long_url: max_long_url)
      expect(link).to be_valid

      link = Shortener::Link.create(long_url: invalid_long_url)
      expect(link).to be_invalid
      expect(link.errors.messages[:long_url]).to eq ["is too long (maximum is #{Shortener::Link::MAX_LONG_URL_LENGTH} characters)"]
    end
  end

  context 'link creation' do
    it 'creates an token automatically when persisting new links' do
      link = Shortener::Link.create(long_url: long_url)

      expect(link.token).to be_present
    end

    it 'retry the token generate until it reaches the max attempts' do
      link = Shortener::Link.create(long_url: long_url)

      allow(Shortener::TokenGenerator).to receive(:generate_new_token).and_return(link.token).exactly(Shortener::TokenGenerator::MAX_ATTEMPTS)

      expect do
        Shortener::Link.create(long_url: long_url)
      end.to raise_error(Shortener::MaxAttemptException)
    end

    it 'retry and fetch a new token before the max attempts' do
      token1 = 'abcde'
      token2 = 'fghij'

      allow(Shortener::TokenGenerator).to receive(:generate_new_token).and_return(token1, token1, token2)
      link1 = Shortener::Link.create(long_url: long_url)
      link2 = Shortener::Link.create(long_url: long_url)

      expect(link1.token).to eq(token1)
      expect(link2.token).to eq(token2)
    end

    it 'allow persist a custom token generated by the user' do
      custom_slug = 'custom-slug'
      link = Shortener::Link.create(long_url: long_url, token: custom_slug)

      expect(link.token).to eq(custom_slug)
    end

    it 'does not re-generate an token when updating a link' do
      link = Shortener::Link.create(long_url: long_url)
      token = link.token
      link.update(long_url: 'https://google.com.br')

      expect(link.token).to eq(token)
    end

    it 'does return the short url with domain' do
      link = Shortener::Link.create(long_url: long_url)

      expect(link.short_url).to eq("http://example.com/#{link.token}")
    end
  end
end
